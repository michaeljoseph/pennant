<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US">
<head>
<link rel="icon" href="/peps/static/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow" />
<link rel="stylesheet" href="/peps/static/style-paper.css" type="text/css" />
<script type="text/javascript" src="/peps/static/mercurial.js"></script>

<link rel="stylesheet" href="/peps/highlightcss" type="text/css" />
<title>peps: 5b21e2a85e78 pep-3101.txt</title>
</head>
<body>

<div class="container">
<div class="menu">
<div class="logo">
<a href="http://hg.python.org">
<img src="/peps/static/hglogo.png" alt="back to hg.python.org repositories" /></a>
</div>
<ul>
<li><a href="/peps/shortlog/5b21e2a85e78">log</a></li>
<li><a href="/peps/graph/5b21e2a85e78">graph</a></li>
<li><a href="/peps/tags">tags</a></li>
<li><a href="/peps/branches">branches</a></li>
</ul>
<ul>
<li><a href="/peps/rev/5b21e2a85e78">changeset</a></li>
<li><a href="/peps/file/5b21e2a85e78/">browse</a></li>
</ul>
<ul>
<li class="active">file</li>
<li><a href="/peps/file/tip/pep-3101.txt">latest</a></li>
<li><a href="/peps/diff/5b21e2a85e78/pep-3101.txt">diff</a></li>
<li><a href="/peps/comparison/5b21e2a85e78/pep-3101.txt">comparison</a></li>
<li><a href="/peps/annotate/5b21e2a85e78/pep-3101.txt">annotate</a></li>
<li><a href="/peps/log/5b21e2a85e78/pep-3101.txt">file log</a></li>
<li><a href="/peps/raw-file/5b21e2a85e78/pep-3101.txt">raw</a></li>
</ul>
<ul>
<li><a href="/peps/help">help</a></li>
</ul>
</div>

<div class="main">
<h2 class="breadcrumb"><a href="/">Mercurial</a> &gt; <a href="/peps">peps</a> </h2>
<h3>view pep-3101.txt @ 5513:5b21e2a85e78</h3>

<form class="search" action="/peps/log">

<p><input name="rev" id="search1" type="text" size="30" /></p>
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/peps/help/revsets">revset expression</a>.</div>
</form>

<div class="description">Mention blog.python.org</div>

<table id="changesetEntry">
<tr>
 <th class="author">author</th>
 <td class="author">&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#75;&#117;&#99;&#104;&#108;&#105;&#110;&#103;&#32;&#60;&#97;&#109;&#107;&#64;&#97;&#109;&#107;&#46;&#99;&#97;&#62;</td>
</tr>
<tr>
 <th class="date">date</th>
 <td class="date age">Fri, 01 Aug 2014 16:39:37 -0400</td>
</tr>
<tr>
 <th class="author">parents</th>
 <td class="author"><a href="/peps/file/2e54b3874605/pep-3101.txt">2e54b3874605</a> </td>
</tr>
<tr>
 <th class="author">children</th>
 <td class="author"></td>
</tr>
</table>

<div class="overflow">
<div class="sourcefirst linewraptoggle">line wrap: <a class="linewraplink" href="javascript:toggleLinewrap()">on</a></div>
<div class="sourcefirst"> line source</div>
<pre class="sourcelines stripes4 wrap">
<span id="l1">PEP: 3101</span><a href="#l1"></a>
<span id="l2">Title: Advanced String Formatting</span><a href="#l2"></a>
<span id="l3">Version: $Revision$</span><a href="#l3"></a>
<span id="l4">Last-Modified: $Date$</span><a href="#l4"></a>
<span id="l5">Author: Talin &lt;talin@acm.org&gt;</span><a href="#l5"></a>
<span id="l6">Status: Final</span><a href="#l6"></a>
<span id="l7">Type: Standards Track</span><a href="#l7"></a>
<span id="l8">Content-Type: text/plain</span><a href="#l8"></a>
<span id="l9">Created: 16-Apr-2006</span><a href="#l9"></a>
<span id="l10">Python-Version: 3.0</span><a href="#l10"></a>
<span id="l11">Post-History: 28-Apr-2006, 6-May-2006, 10-Jun-2007, 14-Aug-2007, 14-Sep-2008</span><a href="#l11"></a>
<span id="l12"></span><a href="#l12"></a>
<span id="l13"></span><a href="#l13"></a>
<span id="l14">Abstract</span><a href="#l14"></a>
<span id="l15"></span><a href="#l15"></a>
<span id="l16">    This PEP proposes a new system for built-in string formatting</span><a href="#l16"></a>
<span id="l17">    operations, intended as a replacement for the existing &#39;%&#39; string</span><a href="#l17"></a>
<span id="l18">    formatting operator.</span><a href="#l18"></a>
<span id="l19"></span><a href="#l19"></a>
<span id="l20"></span><a href="#l20"></a>
<span id="l21">Rationale</span><a href="#l21"></a>
<span id="l22"></span><a href="#l22"></a>
<span id="l23">    Python currently provides two methods of string interpolation:</span><a href="#l23"></a>
<span id="l24"></span><a href="#l24"></a>
<span id="l25">    - The &#39;%&#39; operator for strings. [1]</span><a href="#l25"></a>
<span id="l26"></span><a href="#l26"></a>
<span id="l27">    - The string.Template module. [2]</span><a href="#l27"></a>
<span id="l28"></span><a href="#l28"></a>
<span id="l29">    The primary scope of this PEP concerns proposals for built-in</span><a href="#l29"></a>
<span id="l30">    string formatting operations (in other words, methods of the</span><a href="#l30"></a>
<span id="l31">    built-in string type).</span><a href="#l31"></a>
<span id="l32"></span><a href="#l32"></a>
<span id="l33">    The &#39;%&#39; operator is primarily limited by the fact that it is a</span><a href="#l33"></a>
<span id="l34">    binary operator, and therefore can take at most two arguments.</span><a href="#l34"></a>
<span id="l35">    One of those arguments is already dedicated to the format string,</span><a href="#l35"></a>
<span id="l36">    leaving all other variables to be squeezed into the remaining</span><a href="#l36"></a>
<span id="l37">    argument.  The current practice is to use either a dictionary or a</span><a href="#l37"></a>
<span id="l38">    tuple as the second argument, but as many people have commented</span><a href="#l38"></a>
<span id="l39">    [3], this lacks flexibility.  The &quot;all or nothing&quot; approach</span><a href="#l39"></a>
<span id="l40">    (meaning that one must choose between only positional arguments,</span><a href="#l40"></a>
<span id="l41">    or only named arguments) is felt to be overly constraining.</span><a href="#l41"></a>
<span id="l42"></span><a href="#l42"></a>
<span id="l43">    While there is some overlap between this proposal and</span><a href="#l43"></a>
<span id="l44">    string.Template, it is felt that each serves a distinct need,</span><a href="#l44"></a>
<span id="l45">    and that one does not obviate the other.  This proposal is for</span><a href="#l45"></a>
<span id="l46">    a mechanism which, like &#39;%&#39;, is efficient for small strings</span><a href="#l46"></a>
<span id="l47">    which are only used once, so, for example, compilation of a</span><a href="#l47"></a>
<span id="l48">    string into a template is not contemplated in this proposal,</span><a href="#l48"></a>
<span id="l49">    although the proposal does take care to define format strings</span><a href="#l49"></a>
<span id="l50">    and the API in such a way that an efficient template package</span><a href="#l50"></a>
<span id="l51">    could reuse the syntax and even some of the underlying</span><a href="#l51"></a>
<span id="l52">    formatting code.</span><a href="#l52"></a>
<span id="l53"></span><a href="#l53"></a>
<span id="l54"></span><a href="#l54"></a>
<span id="l55">Specification</span><a href="#l55"></a>
<span id="l56"></span><a href="#l56"></a>
<span id="l57">    The specification will consist of the following parts:</span><a href="#l57"></a>
<span id="l58"></span><a href="#l58"></a>
<span id="l59">    - Specification of a new formatting method to be added to the</span><a href="#l59"></a>
<span id="l60">      built-in string class.</span><a href="#l60"></a>
<span id="l61"></span><a href="#l61"></a>
<span id="l62">    - Specification of functions and flag values to be added to</span><a href="#l62"></a>
<span id="l63">      the string module, so that the underlying formatting engine</span><a href="#l63"></a>
<span id="l64">      can be used with additional options.</span><a href="#l64"></a>
<span id="l65"></span><a href="#l65"></a>
<span id="l66">    - Specification of a new syntax for format strings.</span><a href="#l66"></a>
<span id="l67"></span><a href="#l67"></a>
<span id="l68">    - Specification of a new set of special methods to control the</span><a href="#l68"></a>
<span id="l69">      formatting and conversion of objects.</span><a href="#l69"></a>
<span id="l70"></span><a href="#l70"></a>
<span id="l71">    - Specification of an API for user-defined formatting classes.</span><a href="#l71"></a>
<span id="l72"></span><a href="#l72"></a>
<span id="l73">    - Specification of how formatting errors are handled.</span><a href="#l73"></a>
<span id="l74"></span><a href="#l74"></a>
<span id="l75">    Note on string encodings: When discussing this PEP in the context</span><a href="#l75"></a>
<span id="l76">    of Python 3.0, it is assumed that all strings are unicode strings,</span><a href="#l76"></a>
<span id="l77">    and that the use of the word &#39;string&#39; in the context of this</span><a href="#l77"></a>
<span id="l78">    document will generally refer to a Python 3.0 string, which is</span><a href="#l78"></a>
<span id="l79">    the same as Python 2.x unicode object.</span><a href="#l79"></a>
<span id="l80"></span><a href="#l80"></a>
<span id="l81">    In the context of Python 2.x, the use of the word &#39;string&#39; in this</span><a href="#l81"></a>
<span id="l82">    document refers to an object which may either be a regular string</span><a href="#l82"></a>
<span id="l83">    or a unicode object.  All of the function call interfaces</span><a href="#l83"></a>
<span id="l84">    described in this PEP can be used for both strings and unicode</span><a href="#l84"></a>
<span id="l85">    objects, and in all cases there is sufficient information</span><a href="#l85"></a>
<span id="l86">    to be able to properly deduce the output string type (in</span><a href="#l86"></a>
<span id="l87">    other words, there is no need for two separate APIs).</span><a href="#l87"></a>
<span id="l88">    In all cases, the type of the format string dominates - that</span><a href="#l88"></a>
<span id="l89">    is, the result of the conversion will always result in an object</span><a href="#l89"></a>
<span id="l90">    that contains the same representation of characters as the</span><a href="#l90"></a>
<span id="l91">    input format string.</span><a href="#l91"></a>
<span id="l92"></span><a href="#l92"></a>
<span id="l93"></span><a href="#l93"></a>
<span id="l94">String Methods</span><a href="#l94"></a>
<span id="l95"></span><a href="#l95"></a>
<span id="l96">    The built-in string class (and also the unicode class in 2.6) will</span><a href="#l96"></a>
<span id="l97">    gain a new method, &#39;format&#39;, which takes an arbitrary number of</span><a href="#l97"></a>
<span id="l98">    positional and keyword arguments:</span><a href="#l98"></a>
<span id="l99"></span><a href="#l99"></a>
<span id="l100">        &quot;The story of {0}, {1}, and {c}&quot;.format(a, b, c=d)</span><a href="#l100"></a>
<span id="l101"></span><a href="#l101"></a>
<span id="l102">    Within a format string, each positional argument is identified</span><a href="#l102"></a>
<span id="l103">    with a number, starting from zero, so in the above example, &#39;a&#39; is</span><a href="#l103"></a>
<span id="l104">    argument 0 and &#39;b&#39; is argument 1.  Each keyword argument is</span><a href="#l104"></a>
<span id="l105">    identified by its keyword name, so in the above example, &#39;c&#39; is</span><a href="#l105"></a>
<span id="l106">    used to refer to the third argument.</span><a href="#l106"></a>
<span id="l107">    </span><a href="#l107"></a>
<span id="l108">    There is also a global built-in function, &#39;format&#39; which formats</span><a href="#l108"></a>
<span id="l109">    a single value:</span><a href="#l109"></a>
<span id="l110">    </span><a href="#l110"></a>
<span id="l111">       print(format(10.0, &quot;7.3g&quot;))</span><a href="#l111"></a>
<span id="l112">       </span><a href="#l112"></a>
<span id="l113">    This function is described in a later section.</span><a href="#l113"></a>
<span id="l114"></span><a href="#l114"></a>
<span id="l115"></span><a href="#l115"></a>
<span id="l116">Format Strings</span><a href="#l116"></a>
<span id="l117"></span><a href="#l117"></a>
<span id="l118">    Format strings consist of intermingled character data and markup.</span><a href="#l118"></a>
<span id="l119"></span><a href="#l119"></a>
<span id="l120">    Character data is data which is transferred unchanged from the</span><a href="#l120"></a>
<span id="l121">    format string to the output string; markup is not transferred from</span><a href="#l121"></a>
<span id="l122">    the format string directly to the output, but instead is used to</span><a href="#l122"></a>
<span id="l123">    define &#39;replacement fields&#39; that describe to the format engine</span><a href="#l123"></a>
<span id="l124">    what should be placed in the output string in place of the markup.</span><a href="#l124"></a>
<span id="l125"></span><a href="#l125"></a>
<span id="l126">    Brace characters (&#39;curly braces&#39;) are used to indicate a</span><a href="#l126"></a>
<span id="l127">    replacement field within the string:</span><a href="#l127"></a>
<span id="l128"></span><a href="#l128"></a>
<span id="l129">        &quot;My name is {0}&quot;.format(&#39;Fred&#39;)</span><a href="#l129"></a>
<span id="l130"></span><a href="#l130"></a>
<span id="l131">    The result of this is the string:</span><a href="#l131"></a>
<span id="l132"></span><a href="#l132"></a>
<span id="l133">        &quot;My name is Fred&quot;</span><a href="#l133"></a>
<span id="l134"></span><a href="#l134"></a>
<span id="l135">    Braces can be escaped by doubling:</span><a href="#l135"></a>
<span id="l136"></span><a href="#l136"></a>
<span id="l137">        &quot;My name is {0} :-{{}}&quot;.format(&#39;Fred&#39;)</span><a href="#l137"></a>
<span id="l138"></span><a href="#l138"></a>
<span id="l139">    Which would produce:</span><a href="#l139"></a>
<span id="l140"></span><a href="#l140"></a>
<span id="l141">        &quot;My name is Fred :-{}&quot;</span><a href="#l141"></a>
<span id="l142"></span><a href="#l142"></a>
<span id="l143">    The element within the braces is called a &#39;field&#39;.  Fields consist</span><a href="#l143"></a>
<span id="l144">    of a &#39;field name&#39;, which can either be simple or compound, and an</span><a href="#l144"></a>
<span id="l145">    optional &#39;format specifier&#39;.</span><a href="#l145"></a>
<span id="l146"></span><a href="#l146"></a>
<span id="l147"></span><a href="#l147"></a>
<span id="l148">Simple and Compound Field Names</span><a href="#l148"></a>
<span id="l149"></span><a href="#l149"></a>
<span id="l150">    Simple field names are either names or numbers.  If numbers, they</span><a href="#l150"></a>
<span id="l151">    must be valid base-10 integers; if names, they must be valid</span><a href="#l151"></a>
<span id="l152">    Python identifiers.  A number is used to identify a positional</span><a href="#l152"></a>
<span id="l153">    argument, while a name is used to identify a keyword argument.</span><a href="#l153"></a>
<span id="l154"></span><a href="#l154"></a>
<span id="l155">    A compound field name is a combination of multiple simple field</span><a href="#l155"></a>
<span id="l156">    names in an expression:</span><a href="#l156"></a>
<span id="l157"></span><a href="#l157"></a>
<span id="l158">        &quot;My name is {0.name}&quot;.format(open(&#39;out.txt&#39;, &#39;w&#39;))</span><a href="#l158"></a>
<span id="l159"></span><a href="#l159"></a>
<span id="l160">    This example shows the use of the &#39;getattr&#39; or &#39;dot&#39; operator</span><a href="#l160"></a>
<span id="l161">    in a field expression.  The dot operator allows an attribute of</span><a href="#l161"></a>
<span id="l162">    an input value to be specified as the field value.</span><a href="#l162"></a>
<span id="l163"></span><a href="#l163"></a>
<span id="l164">    Unlike some other programming languages, you cannot embed arbitrary</span><a href="#l164"></a>
<span id="l165">    expressions in format strings.  This is by design - the types of</span><a href="#l165"></a>
<span id="l166">    expressions that you can use is deliberately limited.  Only two operators</span><a href="#l166"></a>
<span id="l167">    are supported: the &#39;.&#39; (getattr) operator, and the &#39;[]&#39; (getitem)</span><a href="#l167"></a>
<span id="l168">    operator.  The reason for allowing these operators is that they don&#39;t</span><a href="#l168"></a>
<span id="l169">    normally have side effects in non-pathological code.</span><a href="#l169"></a>
<span id="l170"></span><a href="#l170"></a>
<span id="l171">    An example of the &#39;getitem&#39; syntax:</span><a href="#l171"></a>
<span id="l172"></span><a href="#l172"></a>
<span id="l173">        &quot;My name is {0[name]}&quot;.format(dict(name=&#39;Fred&#39;))</span><a href="#l173"></a>
<span id="l174"></span><a href="#l174"></a>
<span id="l175">    It should be noted that the use of &#39;getitem&#39; within a format string</span><a href="#l175"></a>
<span id="l176">    is much more limited than its conventional usage.  In the above example,</span><a href="#l176"></a>
<span id="l177">    the string &#39;name&#39; really is the literal string &#39;name&#39;, not a variable</span><a href="#l177"></a>
<span id="l178">    named &#39;name&#39;.  The rules for parsing an item key are very simple.</span><a href="#l178"></a>
<span id="l179">    If it starts with a digit, then it is treated as a number, otherwise</span><a href="#l179"></a>
<span id="l180">    it is used as a string.</span><a href="#l180"></a>
<span id="l181"></span><a href="#l181"></a>
<span id="l182">    Because keys are not quote-delimited, it is not possible to</span><a href="#l182"></a>
<span id="l183">    specify arbitrary dictionary keys (e.g., the strings &quot;10&quot; or</span><a href="#l183"></a>
<span id="l184">    &quot;:-]&quot;) from within a format string.</span><a href="#l184"></a>
<span id="l185"></span><a href="#l185"></a>
<span id="l186">    Implementation note: The implementation of this proposal is</span><a href="#l186"></a>
<span id="l187">    not required to enforce the rule about a simple or dotted name</span><a href="#l187"></a>
<span id="l188">    being a valid Python identifier.  Instead, it will rely on the</span><a href="#l188"></a>
<span id="l189">    getattr function of the underlying object to throw an exception if</span><a href="#l189"></a>
<span id="l190">    the identifier is not legal.  The str.format() function will have</span><a href="#l190"></a>
<span id="l191">    a minimalist parser which only attempts to figure out when it is</span><a href="#l191"></a>
<span id="l192">    &quot;done&quot; with an identifier (by finding a &#39;.&#39; or a &#39;]&#39;, or &#39;}&#39;,</span><a href="#l192"></a>
<span id="l193">    etc.).</span><a href="#l193"></a>
<span id="l194"></span><a href="#l194"></a>
<span id="l195"></span><a href="#l195"></a>
<span id="l196">Format Specifiers</span><a href="#l196"></a>
<span id="l197"></span><a href="#l197"></a>
<span id="l198">    Each field can also specify an optional set of &#39;format</span><a href="#l198"></a>
<span id="l199">    specifiers&#39; which can be used to adjust the format of that field.</span><a href="#l199"></a>
<span id="l200">    Format specifiers follow the field name, with a colon (&#39;:&#39;)</span><a href="#l200"></a>
<span id="l201">    character separating the two:</span><a href="#l201"></a>
<span id="l202"></span><a href="#l202"></a>
<span id="l203">        &quot;My name is {0:8}&quot;.format(&#39;Fred&#39;)</span><a href="#l203"></a>
<span id="l204"></span><a href="#l204"></a>
<span id="l205">    The meaning and syntax of the format specifiers depends on the</span><a href="#l205"></a>
<span id="l206">    type of object that is being formatted, but there is a standard</span><a href="#l206"></a>
<span id="l207">    set of format specifiers used for any object that does not</span><a href="#l207"></a>
<span id="l208">    override them.</span><a href="#l208"></a>
<span id="l209"></span><a href="#l209"></a>
<span id="l210">    Format specifiers can themselves contain replacement fields.</span><a href="#l210"></a>
<span id="l211">    For example, a field whose field width is itself a parameter</span><a href="#l211"></a>
<span id="l212">    could be specified via:</span><a href="#l212"></a>
<span id="l213"></span><a href="#l213"></a>
<span id="l214">        &quot;{0:{1}}&quot;.format(a, b)</span><a href="#l214"></a>
<span id="l215"></span><a href="#l215"></a>
<span id="l216">    These &#39;internal&#39; replacement fields can only occur in the format</span><a href="#l216"></a>
<span id="l217">    specifier part of the replacement field.  Internal replacement fields</span><a href="#l217"></a>
<span id="l218">    cannot themselves have format specifiers.  This implies also that</span><a href="#l218"></a>
<span id="l219">    replacement fields cannot be nested to arbitrary levels.</span><a href="#l219"></a>
<span id="l220"></span><a href="#l220"></a>
<span id="l221">    Note that the doubled &#39;}&#39; at the end, which would normally be</span><a href="#l221"></a>
<span id="l222">    escaped, is not escaped in this case.  The reason is because</span><a href="#l222"></a>
<span id="l223">    the &#39;{{&#39; and &#39;}}&#39; syntax for escapes is only applied when used</span><a href="#l223"></a>
<span id="l224">    *outside* of a format field.  Within a format field, the brace</span><a href="#l224"></a>
<span id="l225">    characters always have their normal meaning.</span><a href="#l225"></a>
<span id="l226"></span><a href="#l226"></a>
<span id="l227">    The syntax for format specifiers is open-ended, since a class</span><a href="#l227"></a>
<span id="l228">    can override the standard format specifiers.  In such cases,</span><a href="#l228"></a>
<span id="l229">    the str.format() method merely passes all of the characters between</span><a href="#l229"></a>
<span id="l230">    the first colon and the matching brace to the relevant underlying</span><a href="#l230"></a>
<span id="l231">    formatting method.</span><a href="#l231"></a>
<span id="l232"></span><a href="#l232"></a>
<span id="l233"></span><a href="#l233"></a>
<span id="l234">Standard Format Specifiers</span><a href="#l234"></a>
<span id="l235"></span><a href="#l235"></a>
<span id="l236">    If an object does not define its own format specifiers, a standard</span><a href="#l236"></a>
<span id="l237">    set of format specifiers is used.  These are similar in concept to</span><a href="#l237"></a>
<span id="l238">    the format specifiers used by the existing &#39;%&#39; operator, however</span><a href="#l238"></a>
<span id="l239">    there are also a number of differences.</span><a href="#l239"></a>
<span id="l240"></span><a href="#l240"></a>
<span id="l241">    The general form of a standard format specifier is:</span><a href="#l241"></a>
<span id="l242"></span><a href="#l242"></a>
<span id="l243">        [[fill]align][sign][#][0][minimumwidth][.precision][type]</span><a href="#l243"></a>
<span id="l244"></span><a href="#l244"></a>
<span id="l245">    The brackets ([]) indicate an optional element.</span><a href="#l245"></a>
<span id="l246"></span><a href="#l246"></a>
<span id="l247">    Then the optional align flag can be one of the following:</span><a href="#l247"></a>
<span id="l248"></span><a href="#l248"></a>
<span id="l249">        &#39;&lt;&#39; - Forces the field to be left-aligned within the available</span><a href="#l249"></a>
<span id="l250">              space (This is the default.)</span><a href="#l250"></a>
<span id="l251">        &#39;&gt;&#39; - Forces the field to be right-aligned within the</span><a href="#l251"></a>
<span id="l252">              available space.</span><a href="#l252"></a>
<span id="l253">        &#39;=&#39; - Forces the padding to be placed after the sign (if any)</span><a href="#l253"></a>
<span id="l254">              but before the digits.  This is used for printing fields</span><a href="#l254"></a>
<span id="l255">              in the form &#39;+000000120&#39;. This alignment option is only</span><a href="#l255"></a>
<span id="l256">              valid for numeric types.</span><a href="#l256"></a>
<span id="l257">        &#39;^&#39; - Forces the field to be centered within the available</span><a href="#l257"></a>
<span id="l258">              space.</span><a href="#l258"></a>
<span id="l259"></span><a href="#l259"></a>
<span id="l260">    Note that unless a minimum field width is defined, the field</span><a href="#l260"></a>
<span id="l261">    width will always be the same size as the data to fill it, so</span><a href="#l261"></a>
<span id="l262">    that the alignment option has no meaning in this case.</span><a href="#l262"></a>
<span id="l263"></span><a href="#l263"></a>
<span id="l264">    The optional &#39;fill&#39; character defines the character to be used to</span><a href="#l264"></a>
<span id="l265">    pad the field to the minimum width.  The fill character, if present,</span><a href="#l265"></a>
<span id="l266">    must be followed by an alignment flag.</span><a href="#l266"></a>
<span id="l267"></span><a href="#l267"></a>
<span id="l268">    The &#39;sign&#39; option is only valid for numeric types, and can be one</span><a href="#l268"></a>
<span id="l269">    of the following:</span><a href="#l269"></a>
<span id="l270"></span><a href="#l270"></a>
<span id="l271">        &#39;+&#39;  - indicates that a sign should be used for both</span><a href="#l271"></a>
<span id="l272">               positive as well as negative numbers</span><a href="#l272"></a>
<span id="l273">        &#39;-&#39;  - indicates that a sign should be used only for negative</span><a href="#l273"></a>
<span id="l274">               numbers (this is the default behavior)</span><a href="#l274"></a>
<span id="l275">        &#39; &#39;  - indicates that a leading space should be used on</span><a href="#l275"></a>
<span id="l276">               positive numbers</span><a href="#l276"></a>
<span id="l277"></span><a href="#l277"></a>
<span id="l278">    If the &#39;#&#39; character is present, integers use the &#39;alternate form&#39;</span><a href="#l278"></a>
<span id="l279">    for formatting.  This means that binary, octal, and hexadecimal</span><a href="#l279"></a>
<span id="l280">    output will be prefixed with &#39;0b&#39;, &#39;0o&#39;, and &#39;0x&#39;, respectively.</span><a href="#l280"></a>
<span id="l281"></span><a href="#l281"></a>
<span id="l282">    &#39;width&#39; is a decimal integer defining the minimum field width.  If</span><a href="#l282"></a>
<span id="l283">    not specified, then the field width will be determined by the</span><a href="#l283"></a>
<span id="l284">    content.</span><a href="#l284"></a>
<span id="l285">    </span><a href="#l285"></a>
<span id="l286">    If the width field is preceded by a zero (&#39;0&#39;) character, this enables</span><a href="#l286"></a>
<span id="l287">    zero-padding.  This is equivalent to an alignment type of &#39;=&#39; and a</span><a href="#l287"></a>
<span id="l288">    fill character of &#39;0&#39;.</span><a href="#l288"></a>
<span id="l289"></span><a href="#l289"></a>
<span id="l290">    The &#39;precision&#39; is a decimal number indicating how many digits</span><a href="#l290"></a>
<span id="l291">    should be displayed after the decimal point in a floating point</span><a href="#l291"></a>
<span id="l292">    conversion.  For non-numeric types the field indicates the maximum</span><a href="#l292"></a>
<span id="l293">    field size - in other words, how many characters will be used from</span><a href="#l293"></a>
<span id="l294">    the field content.  The precision is ignored for integer conversions.</span><a href="#l294"></a>
<span id="l295"></span><a href="#l295"></a>
<span id="l296">    Finally, the &#39;type&#39; determines how the data should be presented.</span><a href="#l296"></a>
<span id="l297">    </span><a href="#l297"></a>
<span id="l298">    The available integer presentation types are:</span><a href="#l298"></a>
<span id="l299"></span><a href="#l299"></a>
<span id="l300">        &#39;b&#39; - Binary. Outputs the number in base 2.</span><a href="#l300"></a>
<span id="l301">        &#39;c&#39; - Character. Converts the integer to the corresponding</span><a href="#l301"></a>
<span id="l302">              Unicode character before printing.</span><a href="#l302"></a>
<span id="l303">        &#39;d&#39; - Decimal Integer. Outputs the number in base 10.</span><a href="#l303"></a>
<span id="l304">        &#39;o&#39; - Octal format. Outputs the number in base 8.</span><a href="#l304"></a>
<span id="l305">        &#39;x&#39; - Hex format. Outputs the number in base 16, using lower-</span><a href="#l305"></a>
<span id="l306">              case letters for the digits above 9.</span><a href="#l306"></a>
<span id="l307">        &#39;X&#39; - Hex format. Outputs the number in base 16, using upper-</span><a href="#l307"></a>
<span id="l308">              case letters for the digits above 9.</span><a href="#l308"></a>
<span id="l309">        &#39;n&#39; - Number. This is the same as &#39;d&#39;, except that it uses the</span><a href="#l309"></a>
<span id="l310">              current locale setting to insert the appropriate</span><a href="#l310"></a>
<span id="l311">              number separator characters.</span><a href="#l311"></a>
<span id="l312">        &#39;&#39; (None) - the same as &#39;d&#39;</span><a href="#l312"></a>
<span id="l313"></span><a href="#l313"></a>
<span id="l314">    The available floating point presentation types are:</span><a href="#l314"></a>
<span id="l315"></span><a href="#l315"></a>
<span id="l316">        &#39;e&#39; - Exponent notation. Prints the number in scientific</span><a href="#l316"></a>
<span id="l317">              notation using the letter &#39;e&#39; to indicate the exponent.</span><a href="#l317"></a>
<span id="l318">        &#39;E&#39; - Exponent notation. Same as &#39;e&#39; except it converts the</span><a href="#l318"></a>
<span id="l319">              number to uppercase.</span><a href="#l319"></a>
<span id="l320">        &#39;f&#39; - Fixed point. Displays the number as a fixed-point</span><a href="#l320"></a>
<span id="l321">              number.</span><a href="#l321"></a>
<span id="l322">        &#39;F&#39; - Fixed point. Same as &#39;f&#39; except it converts the number</span><a href="#l322"></a>
<span id="l323">              to uppercase.</span><a href="#l323"></a>
<span id="l324">        &#39;g&#39; - General format. This prints the number as a fixed-point</span><a href="#l324"></a>
<span id="l325">              number, unless the number is too large, in which case</span><a href="#l325"></a>
<span id="l326">              it switches to &#39;e&#39; exponent notation.</span><a href="#l326"></a>
<span id="l327">        &#39;G&#39; - General format. Same as &#39;g&#39; except switches to &#39;E&#39;</span><a href="#l327"></a>
<span id="l328">              if the number gets to large.</span><a href="#l328"></a>
<span id="l329">        &#39;n&#39; - Number. This is the same as &#39;g&#39;, except that it uses the</span><a href="#l329"></a>
<span id="l330">              current locale setting to insert the appropriate</span><a href="#l330"></a>
<span id="l331">              number separator characters.</span><a href="#l331"></a>
<span id="l332">        &#39;%&#39; - Percentage. Multiplies the number by 100 and displays</span><a href="#l332"></a>
<span id="l333">              in fixed (&#39;f&#39;) format, followed by a percent sign.</span><a href="#l333"></a>
<span id="l334">        &#39;&#39; (None) - similar to &#39;g&#39;, except that it prints at least one</span><a href="#l334"></a>
<span id="l335">              digit after the decimal point.</span><a href="#l335"></a>
<span id="l336"></span><a href="#l336"></a>
<span id="l337">    Objects are able to define their own format specifiers to</span><a href="#l337"></a>
<span id="l338">    replace the standard ones.  An example is the &#39;datetime&#39; class,</span><a href="#l338"></a>
<span id="l339">    whose format specifiers might look something like the</span><a href="#l339"></a>
<span id="l340">    arguments to the strftime() function:</span><a href="#l340"></a>
<span id="l341"></span><a href="#l341"></a>
<span id="l342">        &quot;Today is: {0:%a %b %d %H:%M:%S %Y}&quot;.format(datetime.now())</span><a href="#l342"></a>
<span id="l343"></span><a href="#l343"></a>
<span id="l344">    For all built-in types, an empty format specification will produce</span><a href="#l344"></a>
<span id="l345">    the equivalent of str(value).  It is recommended that objects</span><a href="#l345"></a>
<span id="l346">    defining their own format specifiers follow this convention as</span><a href="#l346"></a>
<span id="l347">    well.</span><a href="#l347"></a>
<span id="l348"></span><a href="#l348"></a>
<span id="l349"></span><a href="#l349"></a>
<span id="l350">Explicit Conversion Flag</span><a href="#l350"></a>
<span id="l351"></span><a href="#l351"></a>
<span id="l352">    The explicit conversion flag is used to transform the format field value</span><a href="#l352"></a>
<span id="l353">    before it is formatted.  This can be used to override the type-specific</span><a href="#l353"></a>
<span id="l354">    formatting behavior, and format the value as if it were a more</span><a href="#l354"></a>
<span id="l355">    generic type.  Currently, two explicit conversion flags are</span><a href="#l355"></a>
<span id="l356">    recognized:</span><a href="#l356"></a>
<span id="l357"></span><a href="#l357"></a>
<span id="l358">        !r - convert the value to a string using repr().</span><a href="#l358"></a>
<span id="l359">        !s - convert the value to a string using str().</span><a href="#l359"></a>
<span id="l360"></span><a href="#l360"></a>
<span id="l361">    These flags are placed before the format specifier:</span><a href="#l361"></a>
<span id="l362"></span><a href="#l362"></a>
<span id="l363">        &quot;{0!r:20}&quot;.format(&quot;Hello&quot;)</span><a href="#l363"></a>
<span id="l364"></span><a href="#l364"></a>
<span id="l365">    In the preceding example, the string &quot;Hello&quot; will be printed, with quotes,</span><a href="#l365"></a>
<span id="l366">    in a field of at least 20 characters width.</span><a href="#l366"></a>
<span id="l367">    </span><a href="#l367"></a>
<span id="l368">    A custom Formatter class can define additional conversion flags.</span><a href="#l368"></a>
<span id="l369">    The built-in formatter will raise a ValueError if an invalid</span><a href="#l369"></a>
<span id="l370">    conversion flag is specified.</span><a href="#l370"></a>
<span id="l371"></span><a href="#l371"></a>
<span id="l372"></span><a href="#l372"></a>
<span id="l373">Controlling Formatting on a Per-Type Basis</span><a href="#l373"></a>
<span id="l374"></span><a href="#l374"></a>
<span id="l375">    Each Python type can control formatting of its instances by defining</span><a href="#l375"></a>
<span id="l376">    a __format__ method.  The __format__ method is responsible for</span><a href="#l376"></a>
<span id="l377">    interpreting the format specifier, formatting the value, and</span><a href="#l377"></a>
<span id="l378">    returning the resulting string.</span><a href="#l378"></a>
<span id="l379">    </span><a href="#l379"></a>
<span id="l380">    The new, global built-in function &#39;format&#39; simply calls this special</span><a href="#l380"></a>
<span id="l381">    method, similar to how len() and str() simply call their respective</span><a href="#l381"></a>
<span id="l382">    special methods:</span><a href="#l382"></a>
<span id="l383">    </span><a href="#l383"></a>
<span id="l384">        def format(value, format_spec):</span><a href="#l384"></a>
<span id="l385">            return value.__format__(format_spec)</span><a href="#l385"></a>
<span id="l386">            </span><a href="#l386"></a>
<span id="l387">    It is safe to call this function with a value of &quot;None&quot; (because the</span><a href="#l387"></a>
<span id="l388">    &quot;None&quot; value in Python is an object and can have methods.)</span><a href="#l388"></a>
<span id="l389"></span><a href="#l389"></a>
<span id="l390">    Several built-in types, including &#39;str&#39;, &#39;int&#39;, &#39;float&#39;, and &#39;object&#39;</span><a href="#l390"></a>
<span id="l391">    define __format__ methods.  This means that if you derive from any of</span><a href="#l391"></a>
<span id="l392">    those types, your class will know how to format itself.</span><a href="#l392"></a>
<span id="l393">    </span><a href="#l393"></a>
<span id="l394">    The object.__format__ method is the simplest: It simply converts the</span><a href="#l394"></a>
<span id="l395">    object to a string, and then calls format again:</span><a href="#l395"></a>
<span id="l396">    </span><a href="#l396"></a>
<span id="l397">        class object:</span><a href="#l397"></a>
<span id="l398">            def __format__(self, format_spec):</span><a href="#l398"></a>
<span id="l399">                return format(str(self), format_spec)</span><a href="#l399"></a>
<span id="l400">                </span><a href="#l400"></a>
<span id="l401">    The __format__ methods for &#39;int&#39; and &#39;float&#39; will do numeric formatting</span><a href="#l401"></a>
<span id="l402">    based on the format specifier.  In some cases, these formatting</span><a href="#l402"></a>
<span id="l403">    operations may be delegated to other types.  So for example, in the case</span><a href="#l403"></a>
<span id="l404">    where the &#39;int&#39; formatter sees a format type of &#39;f&#39; (meaning &#39;float&#39;)</span><a href="#l404"></a>
<span id="l405">    it can simply cast the value to a float and call format() again.</span><a href="#l405"></a>
<span id="l406">    </span><a href="#l406"></a>
<span id="l407">    Any class can override the __format__ method to provide custom</span><a href="#l407"></a>
<span id="l408">    formatting for that type:</span><a href="#l408"></a>
<span id="l409"></span><a href="#l409"></a>
<span id="l410">        class AST:</span><a href="#l410"></a>
<span id="l411">            def __format__(self, format_spec):</span><a href="#l411"></a>
<span id="l412">                ...</span><a href="#l412"></a>
<span id="l413"></span><a href="#l413"></a>
<span id="l414">    Note for Python 2.x: The &#39;format_spec&#39; argument will be either</span><a href="#l414"></a>
<span id="l415">    a string object or a unicode object, depending on the type of the</span><a href="#l415"></a>
<span id="l416">    original format string.  The __format__ method should test the type</span><a href="#l416"></a>
<span id="l417">    of the specifiers parameter to determine whether to return a string or</span><a href="#l417"></a>
<span id="l418">    unicode object.  It is the responsibility of the __format__ method</span><a href="#l418"></a>
<span id="l419">    to return an object of the proper type.</span><a href="#l419"></a>
<span id="l420">    </span><a href="#l420"></a>
<span id="l421">    Note that the &#39;explicit conversion&#39; flag mentioned above is not passed</span><a href="#l421"></a>
<span id="l422">    to the __format__ method.  Rather, it is expected that the conversion</span><a href="#l422"></a>
<span id="l423">    specified by the flag will be performed before calling __format__.</span><a href="#l423"></a>
<span id="l424"></span><a href="#l424"></a>
<span id="l425"></span><a href="#l425"></a>
<span id="l426">User-Defined Formatting</span><a href="#l426"></a>
<span id="l427"></span><a href="#l427"></a>
<span id="l428">    There will be times when customizing the formatting of fields</span><a href="#l428"></a>
<span id="l429">    on a per-type basis is not enough.  An example might be a</span><a href="#l429"></a>
<span id="l430">    spreadsheet application, which displays hash marks &#39;#&#39; when a value</span><a href="#l430"></a>
<span id="l431">    is too large to fit in the available space.</span><a href="#l431"></a>
<span id="l432"></span><a href="#l432"></a>
<span id="l433">    For more powerful and flexible formatting, access to the underlying</span><a href="#l433"></a>
<span id="l434">    format engine can be obtained through the &#39;Formatter&#39; class that</span><a href="#l434"></a>
<span id="l435">    lives in the &#39;string&#39; module.  This class takes additional options</span><a href="#l435"></a>
<span id="l436">    which are not accessible via the normal str.format method.</span><a href="#l436"></a>
<span id="l437">    </span><a href="#l437"></a>
<span id="l438">    An application can subclass the Formatter class to create its own</span><a href="#l438"></a>
<span id="l439">    customized formatting behavior.</span><a href="#l439"></a>
<span id="l440"></span><a href="#l440"></a>
<span id="l441">    The PEP does not attempt to exactly specify all methods and</span><a href="#l441"></a>
<span id="l442">    properties defined by the Formatter class; instead, those will be</span><a href="#l442"></a>
<span id="l443">    defined and documented in the initial implementation.  However, this</span><a href="#l443"></a>
<span id="l444">    PEP will specify the general requirements for the Formatter class,</span><a href="#l444"></a>
<span id="l445">    which are listed below.</span><a href="#l445"></a>
<span id="l446"></span><a href="#l446"></a>
<span id="l447">    Although string.format() does not directly use the Formatter class</span><a href="#l447"></a>
<span id="l448">    to do formatting, both use the same underlying implementation.  The</span><a href="#l448"></a>
<span id="l449">    reason that string.format() does not use the Formatter class directly</span><a href="#l449"></a>
<span id="l450">    is because &quot;string&quot; is a built-in type, which means that all of its</span><a href="#l450"></a>
<span id="l451">    methods must be implemented in C, whereas Formatter is a Python</span><a href="#l451"></a>
<span id="l452">    class.  Formatter provides an extensible wrapper around the same</span><a href="#l452"></a>
<span id="l453">    C functions as are used by string.format().</span><a href="#l453"></a>
<span id="l454"></span><a href="#l454"></a>
<span id="l455"></span><a href="#l455"></a>
<span id="l456">Formatter Methods</span><a href="#l456"></a>
<span id="l457"></span><a href="#l457"></a>
<span id="l458">    The Formatter class takes no initialization arguments:</span><a href="#l458"></a>
<span id="l459">    </span><a href="#l459"></a>
<span id="l460">        fmt = Formatter()</span><a href="#l460"></a>
<span id="l461"></span><a href="#l461"></a>
<span id="l462">    The public API methods of class Formatter are as follows:</span><a href="#l462"></a>
<span id="l463"></span><a href="#l463"></a>
<span id="l464">        -- format(format_string, *args, **kwargs)</span><a href="#l464"></a>
<span id="l465">        -- vformat(format_string, args, kwargs)</span><a href="#l465"></a>
<span id="l466">        </span><a href="#l466"></a>
<span id="l467">    &#39;format&#39; is the primary API method.  It takes a format template,</span><a href="#l467"></a>
<span id="l468">    and an arbitrary set of positional and keyword arguments.</span><a href="#l468"></a>
<span id="l469">    &#39;format&#39; is just a wrapper that calls &#39;vformat&#39;.</span><a href="#l469"></a>
<span id="l470"></span><a href="#l470"></a>
<span id="l471">    &#39;vformat&#39; is the function that does the actual work of formatting.  It</span><a href="#l471"></a>
<span id="l472">    is exposed as a separate function for cases where you want to pass in</span><a href="#l472"></a>
<span id="l473">    a predefined dictionary of arguments, rather than unpacking and</span><a href="#l473"></a>
<span id="l474">    repacking the dictionary as individual arguments using the &#39;*args&#39; and</span><a href="#l474"></a>
<span id="l475">    &#39;**kwds&#39; syntax.  &#39;vformat&#39; does the work of breaking up the format</span><a href="#l475"></a>
<span id="l476">    template string into character data and replacement fields.  It calls</span><a href="#l476"></a>
<span id="l477">    the &#39;get_positional&#39; and &#39;get_index&#39; methods as appropriate (described</span><a href="#l477"></a>
<span id="l478">    below.)</span><a href="#l478"></a>
<span id="l479"></span><a href="#l479"></a>
<span id="l480">    Formatter defines the following overridable methods:</span><a href="#l480"></a>
<span id="l481">        </span><a href="#l481"></a>
<span id="l482">        -- get_value(key, args, kwargs)</span><a href="#l482"></a>
<span id="l483">        -- check_unused_args(used_args, args, kwargs)</span><a href="#l483"></a>
<span id="l484">        -- format_field(value, format_spec)</span><a href="#l484"></a>
<span id="l485"></span><a href="#l485"></a>
<span id="l486">    &#39;get_value&#39; is used to retrieve a given field value.  The &#39;key&#39; argument</span><a href="#l486"></a>
<span id="l487">    will be either an integer or a string.  If it is an integer, it represents</span><a href="#l487"></a>
<span id="l488">    the index of the positional argument in &#39;args&#39;; If it is a string, then</span><a href="#l488"></a>
<span id="l489">    it represents a named argument in &#39;kwargs&#39;.</span><a href="#l489"></a>
<span id="l490">    </span><a href="#l490"></a>
<span id="l491">    The &#39;args&#39; parameter is set to the list of positional arguments to</span><a href="#l491"></a>
<span id="l492">    &#39;vformat&#39;, and the &#39;kwargs&#39; parameter is set to the dictionary of</span><a href="#l492"></a>
<span id="l493">    positional arguments.</span><a href="#l493"></a>
<span id="l494">    </span><a href="#l494"></a>
<span id="l495">    For compound field names, these functions are only called for the</span><a href="#l495"></a>
<span id="l496">    first component of the field name; subsequent components are handled</span><a href="#l496"></a>
<span id="l497">    through normal attribute and indexing operations.</span><a href="#l497"></a>
<span id="l498">    </span><a href="#l498"></a>
<span id="l499">    So for example, the field expression &#39;0.name&#39; would cause &#39;get_value&#39;</span><a href="#l499"></a>
<span id="l500">    to be called with a &#39;key&#39; argument of 0.  The &#39;name&#39; attribute will be</span><a href="#l500"></a>
<span id="l501">    looked up after &#39;get_value&#39; returns by calling the built-in &#39;getattr&#39;</span><a href="#l501"></a>
<span id="l502">    function.</span><a href="#l502"></a>
<span id="l503"></span><a href="#l503"></a>
<span id="l504">    If the index or keyword refers to an item that does not exist, then an</span><a href="#l504"></a>
<span id="l505">    IndexError/KeyError should be raised.</span><a href="#l505"></a>
<span id="l506">    </span><a href="#l506"></a>
<span id="l507">    &#39;check_unused_args&#39; is used to implement checking for unused arguments</span><a href="#l507"></a>
<span id="l508">    if desired.  The arguments to this function is the set of all argument</span><a href="#l508"></a>
<span id="l509">    keys that were actually referred to in the format string (integers for</span><a href="#l509"></a>
<span id="l510">    positional arguments, and strings for named arguments), and a reference</span><a href="#l510"></a>
<span id="l511">    to the args and kwargs that was passed to vformat.  The set of unused</span><a href="#l511"></a>
<span id="l512">    args can be calculated from these parameters.  &#39;check_unused_args&#39;</span><a href="#l512"></a>
<span id="l513">    is assumed to throw an exception if the check fails.</span><a href="#l513"></a>
<span id="l514">    </span><a href="#l514"></a>
<span id="l515">    &#39;format_field&#39; simply calls the global &#39;format&#39; built-in.  The method</span><a href="#l515"></a>
<span id="l516">    is provided so that subclasses can override it.</span><a href="#l516"></a>
<span id="l517"></span><a href="#l517"></a>
<span id="l518">    To get a better understanding of how these functions relate to each</span><a href="#l518"></a>
<span id="l519">    other, here is pseudocode that explains the general operation of</span><a href="#l519"></a>
<span id="l520">    vformat.</span><a href="#l520"></a>
<span id="l521">    </span><a href="#l521"></a>
<span id="l522">        def vformat(format_string, args, kwargs):</span><a href="#l522"></a>
<span id="l523">        </span><a href="#l523"></a>
<span id="l524">          # Output buffer and set of used args</span><a href="#l524"></a>
<span id="l525">          buffer = StringIO.StringIO()</span><a href="#l525"></a>
<span id="l526">          used_args = set()</span><a href="#l526"></a>
<span id="l527">          </span><a href="#l527"></a>
<span id="l528">          # Tokens are either format fields or literal strings</span><a href="#l528"></a>
<span id="l529">          for token in self.parse(format_string):</span><a href="#l529"></a>
<span id="l530">            if is_format_field(token):</span><a href="#l530"></a>
<span id="l531">              # Split the token into field value and format spec</span><a href="#l531"></a>
<span id="l532">              field_spec, _, format_spec = token.partition(&quot;:&quot;)</span><a href="#l532"></a>
<span id="l533">              </span><a href="#l533"></a>
<span id="l534">              # Check for explicit type conversion</span><a href="#l534"></a>
<span id="l535">              explicit, _, field_spec  = field_spec.rpartition(&quot;!&quot;)</span><a href="#l535"></a>
<span id="l536">              </span><a href="#l536"></a>
<span id="l537">              # &#39;first_part&#39; is the part before the first &#39;.&#39; or &#39;[&#39;</span><a href="#l537"></a>
<span id="l538">              # Assume that &#39;get_first_part&#39; returns either an int or</span><a href="#l538"></a>
<span id="l539">              # a string, depending on the syntax.</span><a href="#l539"></a>
<span id="l540">              first_part = get_first_part(field_spec)</span><a href="#l540"></a>
<span id="l541">              value = self.get_value(first_part, args, kwargs)</span><a href="#l541"></a>
<span id="l542">              </span><a href="#l542"></a>
<span id="l543">              # Record the fact that we used this arg</span><a href="#l543"></a>
<span id="l544">              used_args.add(first_part)</span><a href="#l544"></a>
<span id="l545">              </span><a href="#l545"></a>
<span id="l546">              # Handle [subfield] or .subfield. Assume that &#39;components&#39;</span><a href="#l546"></a>
<span id="l547">              # returns an iterator of the various subfields, not including</span><a href="#l547"></a>
<span id="l548">              # the first part.</span><a href="#l548"></a>
<span id="l549">              for comp in components(field_spec):</span><a href="#l549"></a>
<span id="l550">                value = resolve_subfield(value, comp)</span><a href="#l550"></a>
<span id="l551"></span><a href="#l551"></a>
<span id="l552">              # Handle explicit type conversion</span><a href="#l552"></a>
<span id="l553">              if explicit == &#39;r&#39;:</span><a href="#l553"></a>
<span id="l554">                value = repr(value)</span><a href="#l554"></a>
<span id="l555">              elif explicit == &#39;s&#39;:</span><a href="#l555"></a>
<span id="l556">                value = str(value)</span><a href="#l556"></a>
<span id="l557"></span><a href="#l557"></a>
<span id="l558">              # Call the global &#39;format&#39; function and write out the converted</span><a href="#l558"></a>
<span id="l559">              # value.</span><a href="#l559"></a>
<span id="l560">              buffer.write(self.format_field(value, format_spec))</span><a href="#l560"></a>
<span id="l561">              </span><a href="#l561"></a>
<span id="l562">            else:</span><a href="#l562"></a>
<span id="l563">              buffer.write(token)</span><a href="#l563"></a>
<span id="l564">              </span><a href="#l564"></a>
<span id="l565">          self.check_unused_args(used_args, args, kwargs)</span><a href="#l565"></a>
<span id="l566">          return buffer.getvalue()</span><a href="#l566"></a>
<span id="l567">          </span><a href="#l567"></a>
<span id="l568">    Note that the actual algorithm of the Formatter class (which will be</span><a href="#l568"></a>
<span id="l569">    implemented in C) may not be the one presented here.  (It&#39;s likely</span><a href="#l569"></a>
<span id="l570">    that the actual implementation won&#39;t be a &#39;class&#39; at all - rather,</span><a href="#l570"></a>
<span id="l571">    vformat may just call a C function which accepts the other overridable</span><a href="#l571"></a>
<span id="l572">    methods as arguments.)  The primary purpose of this code example is to</span><a href="#l572"></a>
<span id="l573">    illustrate the order in which overridable methods are called.</span><a href="#l573"></a>
<span id="l574"></span><a href="#l574"></a>
<span id="l575"></span><a href="#l575"></a>
<span id="l576">Customizing Formatters</span><a href="#l576"></a>
<span id="l577"></span><a href="#l577"></a>
<span id="l578">    This section describes some typical ways that Formatter objects</span><a href="#l578"></a>
<span id="l579">    can be customized.</span><a href="#l579"></a>
<span id="l580"></span><a href="#l580"></a>
<span id="l581">    To support alternative format-string syntax, the &#39;vformat&#39; method</span><a href="#l581"></a>
<span id="l582">    can be overridden to alter the way format strings are parsed.</span><a href="#l582"></a>
<span id="l583"></span><a href="#l583"></a>
<span id="l584">    One common desire is to support a &#39;default&#39; namespace, so that</span><a href="#l584"></a>
<span id="l585">    you don&#39;t need to pass in keyword arguments to the format()</span><a href="#l585"></a>
<span id="l586">    method, but can instead use values in a pre-existing namespace.</span><a href="#l586"></a>
<span id="l587">    This can easily be done by overriding get_value() as follows:</span><a href="#l587"></a>
<span id="l588"></span><a href="#l588"></a>
<span id="l589">       class NamespaceFormatter(Formatter):</span><a href="#l589"></a>
<span id="l590">          def __init__(self, namespace={}):</span><a href="#l590"></a>
<span id="l591">              Formatter.__init__(self)</span><a href="#l591"></a>
<span id="l592">              self.namespace = namespace</span><a href="#l592"></a>
<span id="l593"></span><a href="#l593"></a>
<span id="l594">          def get_value(self, key, args, kwds):</span><a href="#l594"></a>
<span id="l595">              if isinstance(key, str):</span><a href="#l595"></a>
<span id="l596">                  try:</span><a href="#l596"></a>
<span id="l597">                      # Check explicitly passed arguments first</span><a href="#l597"></a>
<span id="l598">                      return kwds[key]</span><a href="#l598"></a>
<span id="l599">                  except KeyError:</span><a href="#l599"></a>
<span id="l600">                      return self.namespace[key]</span><a href="#l600"></a>
<span id="l601">              else:</span><a href="#l601"></a>
<span id="l602">                  Formatter.get_value(key, args, kwds)</span><a href="#l602"></a>
<span id="l603"></span><a href="#l603"></a>
<span id="l604">    One can use this to easily create a formatting function that allows</span><a href="#l604"></a>
<span id="l605">    access to global variables, for example:</span><a href="#l605"></a>
<span id="l606"></span><a href="#l606"></a>
<span id="l607">        fmt = NamespaceFormatter(globals())</span><a href="#l607"></a>
<span id="l608"></span><a href="#l608"></a>
<span id="l609">        greeting = &quot;hello&quot;</span><a href="#l609"></a>
<span id="l610">        print(fmt.format(&quot;{greeting}, world!&quot;))</span><a href="#l610"></a>
<span id="l611"></span><a href="#l611"></a>
<span id="l612">    A similar technique can be done with the locals() dictionary to</span><a href="#l612"></a>
<span id="l613">    gain access to the locals dictionary.</span><a href="#l613"></a>
<span id="l614"></span><a href="#l614"></a>
<span id="l615">    It would also be possible to create a &#39;smart&#39; namespace formatter</span><a href="#l615"></a>
<span id="l616">    that could automatically access both locals and globals through</span><a href="#l616"></a>
<span id="l617">    snooping of the calling stack.  Due to the need for compatibility</span><a href="#l617"></a>
<span id="l618">    with the different versions of Python, such a capability will not</span><a href="#l618"></a>
<span id="l619">    be included in the standard library, however it is anticipated</span><a href="#l619"></a>
<span id="l620">    that someone will create and publish a recipe for doing this.</span><a href="#l620"></a>
<span id="l621"></span><a href="#l621"></a>
<span id="l622">    Another type of customization is to change the way that built-in</span><a href="#l622"></a>
<span id="l623">    types are formatted by overriding the &#39;format_field&#39; method.  (For</span><a href="#l623"></a>
<span id="l624">    non-built-in types, you can simply define a __format__ special</span><a href="#l624"></a>
<span id="l625">    method on that type.)  So for example, you could override the</span><a href="#l625"></a>
<span id="l626">    formatting of numbers to output scientific notation when needed.</span><a href="#l626"></a>
<span id="l627"></span><a href="#l627"></a>
<span id="l628"></span><a href="#l628"></a>
<span id="l629">Error handling</span><a href="#l629"></a>
<span id="l630"></span><a href="#l630"></a>
<span id="l631">    There are two classes of exceptions which can occur during formatting:</span><a href="#l631"></a>
<span id="l632">    exceptions generated by the formatter code itself, and exceptions</span><a href="#l632"></a>
<span id="l633">    generated by user code (such as a field object&#39;s &#39;getattr&#39; function).</span><a href="#l633"></a>
<span id="l634"></span><a href="#l634"></a>
<span id="l635">    In general, exceptions generated by the formatter code itself are</span><a href="#l635"></a>
<span id="l636">    of the &quot;ValueError&quot; variety -- there is an error in the actual &quot;value&quot;</span><a href="#l636"></a>
<span id="l637">    of the format string.  (This is not always true; for example, the</span><a href="#l637"></a>
<span id="l638">    string.format() function might be passed a non-string as its first</span><a href="#l638"></a>
<span id="l639">    parameter, which would result in a TypeError.)</span><a href="#l639"></a>
<span id="l640"></span><a href="#l640"></a>
<span id="l641">    The text associated with these internally generated ValueError</span><a href="#l641"></a>
<span id="l642">    exceptions will indicate the location of the exception inside</span><a href="#l642"></a>
<span id="l643">    the format string, as well as the nature of the exception.</span><a href="#l643"></a>
<span id="l644"></span><a href="#l644"></a>
<span id="l645">    For exceptions generated by user code, a trace record and</span><a href="#l645"></a>
<span id="l646">    dummy frame will be added to the traceback stack to help</span><a href="#l646"></a>
<span id="l647">    in determining the location in the string where the exception</span><a href="#l647"></a>
<span id="l648">    occurred.  The inserted traceback will indicate that the</span><a href="#l648"></a>
<span id="l649">    error occurred at:</span><a href="#l649"></a>
<span id="l650"></span><a href="#l650"></a>
<span id="l651">        File &quot;&lt;format_string&gt;;&quot;, line XX, in column_YY</span><a href="#l651"></a>
<span id="l652"></span><a href="#l652"></a>
<span id="l653">    where XX and YY represent the line and character position</span><a href="#l653"></a>
<span id="l654">    information in the string, respectively.</span><a href="#l654"></a>
<span id="l655"></span><a href="#l655"></a>
<span id="l656"></span><a href="#l656"></a>
<span id="l657">Alternate Syntax</span><a href="#l657"></a>
<span id="l658"></span><a href="#l658"></a>
<span id="l659">    Naturally, one of the most contentious issues is the syntax of the</span><a href="#l659"></a>
<span id="l660">    format strings, and in particular the markup conventions used to</span><a href="#l660"></a>
<span id="l661">    indicate fields.</span><a href="#l661"></a>
<span id="l662"></span><a href="#l662"></a>
<span id="l663">    Rather than attempting to exhaustively list all of the various</span><a href="#l663"></a>
<span id="l664">    proposals, I will cover the ones that are most widely used</span><a href="#l664"></a>
<span id="l665">    already.</span><a href="#l665"></a>
<span id="l666"></span><a href="#l666"></a>
<span id="l667">    - Shell variable syntax: $name and $(name) (or in some variants,</span><a href="#l667"></a>
<span id="l668">      ${name}).  This is probably the oldest convention out there, and</span><a href="#l668"></a>
<span id="l669">      is used by Perl and many others.  When used without the braces,</span><a href="#l669"></a>
<span id="l670">      the length of the variable is determined by lexically scanning</span><a href="#l670"></a>
<span id="l671">      until an invalid character is found.</span><a href="#l671"></a>
<span id="l672"></span><a href="#l672"></a>
<span id="l673">      This scheme is generally used in cases where interpolation is</span><a href="#l673"></a>
<span id="l674">      implicit - that is, in environments where any string can contain</span><a href="#l674"></a>
<span id="l675">      interpolation variables, and no special substitution function</span><a href="#l675"></a>
<span id="l676">      need be invoked.  In such cases, it is important to prevent the</span><a href="#l676"></a>
<span id="l677">      interpolation behavior from occurring accidentally, so the &#39;$&#39;</span><a href="#l677"></a>
<span id="l678">      (which is otherwise a relatively uncommonly-used character) is</span><a href="#l678"></a>
<span id="l679">      used to signal when the behavior should occur.</span><a href="#l679"></a>
<span id="l680"></span><a href="#l680"></a>
<span id="l681">      It is the author&#39;s opinion, however, that in cases where the</span><a href="#l681"></a>
<span id="l682">      formatting is explicitly invoked, that less care needs to be</span><a href="#l682"></a>
<span id="l683">      taken to prevent accidental interpolation, in which case a</span><a href="#l683"></a>
<span id="l684">      lighter and less unwieldy syntax can be used.</span><a href="#l684"></a>
<span id="l685"></span><a href="#l685"></a>
<span id="l686">    - printf and its cousins (&#39;%&#39;), including variations that add a</span><a href="#l686"></a>
<span id="l687">      field index, so that fields can be interpolated out of order.</span><a href="#l687"></a>
<span id="l688"></span><a href="#l688"></a>
<span id="l689">    - Other bracket-only variations.  Various MUDs (Multi-User</span><a href="#l689"></a>
<span id="l690">      Dungeons) such as MUSH have used brackets (e.g. [name]) to do</span><a href="#l690"></a>
<span id="l691">      string interpolation.  The Microsoft .Net libraries uses braces</span><a href="#l691"></a>
<span id="l692">      ({}), and a syntax which is very similar to the one in this</span><a href="#l692"></a>
<span id="l693">      proposal, although the syntax for format specifiers is quite</span><a href="#l693"></a>
<span id="l694">      different. [4]</span><a href="#l694"></a>
<span id="l695"></span><a href="#l695"></a>
<span id="l696">    - Backquoting.  This method has the benefit of minimal syntactical</span><a href="#l696"></a>
<span id="l697">      clutter, however it lacks many of the benefits of a function</span><a href="#l697"></a>
<span id="l698">      call syntax (such as complex expression arguments, custom</span><a href="#l698"></a>
<span id="l699">      formatters, etc.).</span><a href="#l699"></a>
<span id="l700"></span><a href="#l700"></a>
<span id="l701">    - Other variations include Ruby&#39;s #{}, PHP&#39;s {$name}, and so</span><a href="#l701"></a>
<span id="l702">      on.</span><a href="#l702"></a>
<span id="l703"></span><a href="#l703"></a>
<span id="l704">    Some specific aspects of the syntax warrant additional comments:</span><a href="#l704"></a>
<span id="l705"></span><a href="#l705"></a>
<span id="l706">    1) Backslash character for escapes.  The original version of</span><a href="#l706"></a>
<span id="l707">    this PEP used backslash rather than doubling to escape a bracket.</span><a href="#l707"></a>
<span id="l708">    This worked because backslashes in Python string literals that</span><a href="#l708"></a>
<span id="l709">    don&#39;t conform to a standard backslash sequence such as &#39;\n&#39;</span><a href="#l709"></a>
<span id="l710">    are left unmodified.  However, this caused a certain amount</span><a href="#l710"></a>
<span id="l711">    of confusion, and led to potential situations of multiple</span><a href="#l711"></a>
<span id="l712">    recursive escapes, i.e. &#39;\\\\{&#39; to place a literal backslash</span><a href="#l712"></a>
<span id="l713">    in front of a bracket.</span><a href="#l713"></a>
<span id="l714"></span><a href="#l714"></a>
<span id="l715">    2) The use of the colon character (&#39;:&#39;) as a separator for</span><a href="#l715"></a>
<span id="l716">    format specifiers.  This was chosen simply because that&#39;s</span><a href="#l716"></a>
<span id="l717">    what .Net uses.</span><a href="#l717"></a>
<span id="l718"></span><a href="#l718"></a>
<span id="l719"></span><a href="#l719"></a>
<span id="l720">Alternate Feature Proposals</span><a href="#l720"></a>
<span id="l721"></span><a href="#l721"></a>
<span id="l722">    Restricting attribute access: An earlier version of the PEP</span><a href="#l722"></a>
<span id="l723">    restricted the ability to access attributes beginning with a</span><a href="#l723"></a>
<span id="l724">    leading underscore, for example &quot;{0}._private&quot;.  However, this</span><a href="#l724"></a>
<span id="l725">    is a useful ability to have when debugging, so the feature</span><a href="#l725"></a>
<span id="l726">    was dropped.</span><a href="#l726"></a>
<span id="l727">    </span><a href="#l727"></a>
<span id="l728">    Some developers suggested that the ability to do &#39;getattr&#39; and</span><a href="#l728"></a>
<span id="l729">    &#39;getitem&#39; access should be dropped entirely.  However, this</span><a href="#l729"></a>
<span id="l730">    is in conflict with the needs of another set of developers who</span><a href="#l730"></a>
<span id="l731">    strongly lobbied for the ability to pass in a large dict as a</span><a href="#l731"></a>
<span id="l732">    single argument (without flattening it into individual keyword</span><a href="#l732"></a>
<span id="l733">    arguments using the **kwargs syntax) and then have the format</span><a href="#l733"></a>
<span id="l734">    string refer to dict entries individually.</span><a href="#l734"></a>
<span id="l735">    </span><a href="#l735"></a>
<span id="l736">    There has also been suggestions to expand the set of expressions</span><a href="#l736"></a>
<span id="l737">    that are allowed in a format string.  However, this was seen</span><a href="#l737"></a>
<span id="l738">    to go against the spirit of TOOWTDI, since the same effect can</span><a href="#l738"></a>
<span id="l739">    be achieved in most cases by executing the same expression on</span><a href="#l739"></a>
<span id="l740">    the parameter before it&#39;s passed in to the formatting function.</span><a href="#l740"></a>
<span id="l741">    For cases where the format string is being use to do arbitrary</span><a href="#l741"></a>
<span id="l742">    formatting in a data-rich environment, it&#39;s recommended to use</span><a href="#l742"></a>
<span id="l743">    a template engine specialized for this purpose, such as</span><a href="#l743"></a>
<span id="l744">    Genshi [5] or Cheetah [6].</span><a href="#l744"></a>
<span id="l745">    </span><a href="#l745"></a>
<span id="l746">    Many other features were considered and rejected because they</span><a href="#l746"></a>
<span id="l747">    could easily be achieved by subclassing Formatter instead of</span><a href="#l747"></a>
<span id="l748">    building the feature into the base implementation.  This includes</span><a href="#l748"></a>
<span id="l749">    alternate syntax, comments in format strings, and many others.</span><a href="#l749"></a>
<span id="l750">    </span><a href="#l750"></a>
<span id="l751"></span><a href="#l751"></a>
<span id="l752">Security Considerations</span><a href="#l752"></a>
<span id="l753"></span><a href="#l753"></a>
<span id="l754">    Historically, string formatting has been a common source of</span><a href="#l754"></a>
<span id="l755">    security holes in web-based applications, particularly if the</span><a href="#l755"></a>
<span id="l756">    string formatting system allows arbitrary expressions to be</span><a href="#l756"></a>
<span id="l757">    embedded in format strings.</span><a href="#l757"></a>
<span id="l758"></span><a href="#l758"></a>
<span id="l759">    The best way to use string formatting in a way that does not</span><a href="#l759"></a>
<span id="l760">    create potential security holes is to never use format strings</span><a href="#l760"></a>
<span id="l761">    that come from an untrusted source.</span><a href="#l761"></a>
<span id="l762">    </span><a href="#l762"></a>
<span id="l763">    Barring that, the next best approach is to ensure that string</span><a href="#l763"></a>
<span id="l764">    formatting has no side effects.  Because of the open nature of</span><a href="#l764"></a>
<span id="l765">    Python, it is impossible to guarantee that any non-trivial</span><a href="#l765"></a>
<span id="l766">    operation has this property.  What this PEP does is limit the</span><a href="#l766"></a>
<span id="l767">    types of expressions in format strings to those in which visible</span><a href="#l767"></a>
<span id="l768">    side effects are both rare and strongly discouraged by the</span><a href="#l768"></a>
<span id="l769">    culture of Python developers.  So for example, attribute access</span><a href="#l769"></a>
<span id="l770">    is allowed because it would be considered pathological to write</span><a href="#l770"></a>
<span id="l771">    code where the mere access of an attribute has visible side</span><a href="#l771"></a>
<span id="l772">    effects (whether the code has *invisible* side effects - such</span><a href="#l772"></a>
<span id="l773">    as creating a cache entry for faster lookup - is irrelevant.)</span><a href="#l773"></a>
<span id="l774"></span><a href="#l774"></a>
<span id="l775"></span><a href="#l775"></a>
<span id="l776">Sample Implementation</span><a href="#l776"></a>
<span id="l777"></span><a href="#l777"></a>
<span id="l778">    An implementation of an earlier version of this PEP was created by</span><a href="#l778"></a>
<span id="l779">    Patrick Maupin and Eric V. Smith, and can be found in the pep3101</span><a href="#l779"></a>
<span id="l780">    sandbox at:</span><a href="#l780"></a>
<span id="l781"></span><a href="#l781"></a>
<span id="l782">       http://svn.python.org/view/sandbox/trunk/pep3101/</span><a href="#l782"></a>
<span id="l783"></span><a href="#l783"></a>
<span id="l784"></span><a href="#l784"></a>
<span id="l785">Backwards Compatibility</span><a href="#l785"></a>
<span id="l786"></span><a href="#l786"></a>
<span id="l787">    Backwards compatibility can be maintained by leaving the existing</span><a href="#l787"></a>
<span id="l788">    mechanisms in place.  The new system does not collide with any of</span><a href="#l788"></a>
<span id="l789">    the method names of the existing string formatting techniques, so</span><a href="#l789"></a>
<span id="l790">    both systems can co-exist until it comes time to deprecate the</span><a href="#l790"></a>
<span id="l791">    older system.</span><a href="#l791"></a>
<span id="l792"></span><a href="#l792"></a>
<span id="l793"></span><a href="#l793"></a>
<span id="l794">References</span><a href="#l794"></a>
<span id="l795"></span><a href="#l795"></a>
<span id="l796">    [1] Python Library Reference - String formating operations</span><a href="#l796"></a>
<span id="l797">        http://docs.python.org/library/stdtypes.html#string-formatting-operations</span><a href="#l797"></a>
<span id="l798"></span><a href="#l798"></a>
<span id="l799">    [2] Python Library References - Template strings</span><a href="#l799"></a>
<span id="l800">        http://docs.python.org/library/string.html#string.Template</span><a href="#l800"></a>
<span id="l801"></span><a href="#l801"></a>
<span id="l802">    [3] [Python-3000] String formating operations in python 3k</span><a href="#l802"></a>
<span id="l803">        http://mail.python.org/pipermail/python-3000/2006-April/000285.html</span><a href="#l803"></a>
<span id="l804"></span><a href="#l804"></a>
<span id="l805">    [4] Composite Formatting - [.Net Framework Developer&#39;s Guide]</span><a href="#l805"></a>
<span id="l806">        http://msdn.microsoft.com/library/en-us/cpguide/html/cpconcompositeformatting.asp?frame=true</span><a href="#l806"></a>
<span id="l807">        </span><a href="#l807"></a>
<span id="l808">    [5] Genshi templating engine.</span><a href="#l808"></a>
<span id="l809">        http://genshi.edgewall.org/</span><a href="#l809"></a>
<span id="l810"></span><a href="#l810"></a>
<span id="l811">    [5] Cheetah - The Python-Powered Template Engine.</span><a href="#l811"></a>
<span id="l812">        http://www.cheetahtemplate.org/</span><a href="#l812"></a>
<span id="l813"></span><a href="#l813"></a>
<span id="l814"></span><a href="#l814"></a>
<span id="l815">Copyright</span><a href="#l815"></a>
<span id="l816"></span><a href="#l816"></a>
<span id="l817">    This document has been placed in the public domain.</span><a href="#l817"></a>
<span id="l818"></span><a href="#l818"></a>
<span id="l819"></span><a href="#l819"></a>
<span id="l820"></span><a href="#l820"></a>
<span id="l821">Local Variables:</span><a href="#l821"></a>
<span id="l822">mode: indented-text</span><a href="#l822"></a>
<span id="l823">indent-tabs-mode: nil</span><a href="#l823"></a>
<span id="l824">sentence-end-double-space: t</span><a href="#l824"></a>
<span id="l825">fill-column: 70</span><a href="#l825"></a>
<span id="l826">coding: utf-8</span><a href="#l826"></a></pre>
<div class="sourcelast"></div>
</div>
</div>
</div>

<script type="text/javascript">process_dates()</script>


</body>
</html>

